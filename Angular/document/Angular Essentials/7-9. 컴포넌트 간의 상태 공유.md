# 9. 컴포넌트 간의 상태 공유

### 1. 컴포넌트의 계층적 트리 구조

Angular 애플리케이션은 컴포넌트를 중심으로 구성된다. 컴포넌트는 재사용이 용이한 구조로 분할하여 작성하며, 이렇게 분할된 컴포넌트를 조립하여 가능한 중복 없이 UI를 생성한다. 컴포넌트는 독립적인 존재이지만, 다른 컴포넌트와 결합도를 낮게 유지하면서 다른 컴포넌트와 상태 정보를 교환할 수 있어야 한다.

분할된 컴포넌트를 조립한다는 것은 컴포넌트를 다른 컴포넌트에서 사용하는 것을 말하는데, 이는 컴포넌트 간에 계층(hierarchy)적 구조가 형성될 수 있음을 의미한다. 따라서 분할된 컴포넌트를 조립하여 구성된 애플리케이션은 컴포넌트 간의 부모-자식 관계롤 표현되는 계층적 트리 구조를 갖는다.

이 계층적 구조는 DOM 트리와 유사한 형태를 가지게 되는데 이를 컴포넌트 트리라고 한다.

컴포넌트는 계층적 트리 구조상에서 상호 작용을 통해 동작하기 때문에 다른 컴포넌트와의 상태 정보의 공유는 필수이며 매우 중요한 의미를 갖는다. Angular 는 컴포넌트 간에 상태 정보를 공유할 수 있는 다양한 방법은 제공한다.

- @Input, @Outpu 데코레이터
- @ViewChild, @ViewChildren, @ContentChild, @ContentChildren 데코레이터
- 서비스 중재자 패턴을 구현한 상태 공유 서비스
- 상태 관리를 위한 외부 라이브러리(ngrx.store, Redux 등) 사용

### 2. 부모 컴포넌트에서 자식 컴포넌트로 상태 전달

**@Input 데코레이터**

form 요소를 가지고 있는 부모 컴포넌트의 경우, 사용자에 의해 상태(state)가 변경되면 이를 자식 컴포넌트와 공유할 필요가 있다. 이러한 경우 부모 컴포넌트는 **프로퍼티 바인딩**을 통해 자식 컴포넌트에게 상태 정보를 전달한다.

자식 컴포넌트는 부모 컴포넌트가 전달한 상태 정보를 **@Input 데코레이터**를 통해 컴포넌트 프로퍼티(입력 프로퍼티)에 바인딩한다.

이때 자식 컴포넌트는 어떤 컴포넌트가 상태 정보를 전달하였는지는 알 필요가 없고, 단지 **전달된 정보의 타입만 알 필요가 있다**. 이것은 다른 컴포넌트와 결합도를 낮게 유지하면서 다른 컴포넌트와 상태 정보를 교환할 수 있다는 것을 의미한다.

**@Input 데코레이터와 setter를 이용한 입력 프로퍼티 조작**

setter와 getter를 사용하여 부모 컴포넌트가 전달한 데이터가 자식 컴포넌트의 입력 프로퍼티에 바인딩되는 시점에 필요한 로직을 동작시킬 수 있다.

### 3. 자식 컴포넌트에서 부모 컴포넌트로 상태 전달

**@Output 데코레이터와 EventEmitter**

자식 컴포넌트는 @Output 데코레이터와 함께 선언된 컴포넌트 프로퍼티(출력 프로퍼티)를 EventEmitter 객체로 초기화한다. 그리고 부모 컴포넌트로 상태를 전달하기 위해 `emit()` 메소드를 사용하여 이벤트를 발생시키면서 상태를 전달한다. 부모 컴포넌트는 자식 컴포넌트가 전달한 상태를 **이벤트 바인딩**을 통해 접수한다.

이때 이벤트를 방출할 컴포넌트(자식)는 어떤 컴포넌트에 이벤트가 전달되는지 알 필요가 없다. 이것은 다른 컴포넌트와 결합도를 낮게 유지하면서 다른 컴포넌트와 상태 정보를 교환할 수 있다는 것을 의미한다.

부모 컴포넌트는 이벤트 바인딩을 통해 자식 컴포넌트가 발생시킨 이벤트를 접수한다.

이때 자식 컴포넌트가 emit 메소드를 호출하면서 인자로 전달한 상태 정보는 `$event` 에 들어 있다.

### 4. Stateful 컴포넌트와 Stateless 컴포넌트

예제 설명

예제를 보면 부모 컴포넌트에서 상태 변화(사용자 추가)가 발생한 경우, 부모 컴포넌트는 자신의 users 배열에 상태 변화를 반영한 후 프로퍼티 바인딩을 통해 자식 컴포넌트에 상태 정보인 users 배열을 전송하였다. 이때 부모 컴포넌트와 자식 컴포넌트는 동일한 users 배열에 대한 참조를 갖는다. 따라서 어느 한쪽에서 users 배열을 변경하면 모두에게 변경이 반영된다. 그런데 자식 컴포넌트에서 상태 변화(사용자 제거)가 발생한 경우, 자식 컴포넌트는 자신이 직접 users 배열을 변경하지 않고 이벤트 바인딩을 통해 부모 컴포넌트에게 users 배열의 변경을 위임하였다. 자식 컴포넌트가 직접 users 배열을 변경하면 이벤트 바인딩을 통해 상태를 공유하지 않아도 될 텐데 왜 이렇게 번거롭게 상태를 주고받는 것일까?

부모 컴포넌트와 자식 컴포넌트 모두 상태 객체 users에 대한 동일한 참조를 갖는다. 따라서 참조를 공유하고 있는 상태 객체 users를 어느 한쪽에서 변경하면 모두에게 변경이 반영되는데 이는 **상태 정보의 변화를 예측**하기 어렵게 만든다. 예제와 같이 간단한 구조로 되어 있다면 문제가 되지 않겠지만 복잡한 계층적 구조를 갖는 애플리케이션의 경우, 컴포넌트마다 상태 정보를 마음대로 변경할 수 있다면 상태 변경을 추적하기 어렵고 의도하지 않은 상태 정보의 변경이 발생하여 문제가 될 수 있다. 따라서 애플리케이션의 상태 정보를 저장하고 변경할 수 있는 **Stateful 컴포넌트(Smart 컴포넌트)**와 상태 정보를 참조하여 화면에 출력할 뿐 직접 변경하지 않는 **Stateless 컴포넌트(Dumb 컴포넌트)**로 구분할 필요가 있다. 작성한 예제에서 부모 컴포넌트는 Stateful 컴포넌트, 자식 컴포넌트는 Stateless 컴포넌트로 설계되었다.

Stateful 컴포넌트는 애플리케이션의 현재 상태 정보를 관리하며 필요에 따라 서버 자원에 접근할 수 있고 Stateless 컴포넌트를 사용하여 뷰를 표현한다. Stateless 컴포넌트는 부수 효과(side effect)를 발생시키지 않는 순수 함수(pure function)와 유사하게 단순히 프로퍼티 바인딩을 통해 상태 정보를 전달받아서 뷰를 렌더링하고 필요에 따라 이벤트를 방출할 뿐, 그 외의 부수효과는 발생시키지 않는다. 부수 효과는 복잡도를 증가시킨다. 비순수(impure)한 Stateful 컴포넌트를 최대한 줄리는 것은 부수 효과를 최대한 억제하는 것과 같다. 이것은 디버깅을 쉽게 만든다.

